 #include <sys/socket.h>#include <netinet/in.h>#include <arpa/inet.h>#include <sys/types.h> #include <cstring>#include <sstream>#include <pthread.h>#include <sys/types.h> #include <sys/socket.h>#include <arpa/inet.h>#include "../include/server.h"#define MAX_LINE 2048Server* Server::serobj = NULL;std::string getString(Json::Value &table){	std::string temp;    Json::StyledWriter writer(temp);    writer.write(table);    return temp;}int update_timer(struct event *timer,int tim){	struct timeval tv;	evutil_timerclear(&tv);	tv.tv_sec = tim;	tv.tv_usec = 0;	event_add(timer,&tv);	return 0;}void worker_read_cb(struct bufferevent *bev, void *ctx){	if(NULL == ctx)		return;	int n,len;	Clienter *clienter = (Clienter *)ctx;	char content[MAX_LINE + 1] = {0,};	while (n = bufferevent_read(bev, content, MAX_LINE),n > 0)	{		content[n] = '\0';	}	char *StrRet = strstr(content,"MSG_AGENT_REGISTER_RSP");	if(StrRet != NULL)	{		event_del(&clienter->timer);		event_assign(&clienter->timer,clienter->base,-1,EV_TIMEOUT,write_timer_cb,clienter);		update_timer(&clienter->timer,120);	}	else	{		std::cout<<"this is worker read cb count :"<<content<<std::endl;	}	return;}void worker_error_cb(struct bufferevent *bev, short what, void *ctx){	if(NULL == ctx)		return;	Clienter *clienter = (Clienter *)ctx;	bufferevent_disable(bev,EV_READ|EV_WRITE);	event_del(&clienter->timer);	event_assign(&clienter->timer,clienter->base,-1,0,connect_server_cb,clienter);	update_timer(&clienter->timer,10);}void *start_base_to_work(void *arg){	if(NULL == arg)		return NULL;	struct event_base *base = (struct event_base *)arg;	event_base_dispatch(base);}void write_timer_cb(evutil_socket_t fd, short event, void *arg){	if(NULL == arg)		return;		Clienter *clienter = (Clienter *)arg;	Json::Value reqConn = Json::Value::null;	reqConn["AgentProtocol"]["Header"]["Version"] = "1.0";	reqConn["AgentProtocol"]["Header"]["CSeq"] = "1";		reqConn["AgentProtocol"]["Header"]["MessageType"] = "MSG_AGENT_REGISTER_REQ";		reqConn["AgentProtocol"]["Body"]["Area"] = "Asia:China:Guangzhou";	reqConn["AgentProtocol"]["Body"]["AuthCode"] = clienter->index;		reqConn["AgentProtocol"]["Body"]["RewriteOemID"] = "General";	reqConn["AgentProtocol"]["Body"]["DevicePort"] = "34567";	reqConn["AgentProtocol"]["Body"]["SerialNumber"] = clienter->index;	std::string strreqCon = getString(reqConn);	int reqbodylen = strreqCon.length();		std::stringstream sl;	sl<<reqbodylen;	std::string strreqconnlen = sl.str();	std::string reqConnHead = "POST / HTTP/1.1\r\n";	std::string reqConnCseq = "CSeq: 3\r\n";	std::string reqConnLen = "Content-Length: ";	std::string reqConnend = "\r\n\r\n";	std::string reqConnHeader = reqConnHead + reqConnCseq + reqConnLen + strreqconnlen + reqConnend;	std::string reqConndata = reqConnHeader + strreqCon;	int reqConndatalen = reqConndata.length();	bufferevent_write(clienter->bufev,reqConndata.c_str(),reqConndatalen);		sl.clear();	return;}void connect_server_cb(evutil_socket_t fd, short event, void *arg){	/*Á¬½Óserver*/	if(NULL == arg)		return;	Clienter *clienter = (Clienter *)arg;	std::cout<<"client id = "<<clienter->index;	int sockfd = socket(AF_INET,SOCK_STREAM,0);	struct sockaddr_in addr;	addr.sin_family = AF_INET;	addr.sin_port = htons(6610);	addr.sin_addr.s_addr = inet_addr("127.0.0.1");	socklen_t addrlen = sizeof(struct sockaddr_in);	int Ret = connect(sockfd, (const struct sockaddr *)&addr,addrlen);	if(Ret == 0)	{		std::cout<<"conn server sucess\n";		evutil_make_socket_nonblocking(sockfd);		bufferevent_setfd(clienter->bufev,sockfd);		bufferevent_enable(clienter->bufev, EV_READ|EV_WRITE);		event_del(&clienter->timer);		event_assign(&clienter->timer,clienter->base,-1,EV_TIMEOUT,write_timer_cb,clienter);		update_timer(&clienter->timer,120);	}	else	{		std::cout<<"conn server failed\n";		event_del(&clienter->timer);		event_assign(&clienter->timer,clienter->base,-1,0,connect_server_cb,clienter);		update_timer(&clienter->timer,10);	}}Server* Server::getInstance(){	if(NULL == serobj)	{		serobj = new Server;
	}
	return serobj;}bool Server::Server_Start(int thread_num,int worker_num){	if(evthread_use_pthreads() != 0) return false;	Thread_Num = thread_num;	Worker_Num = worker_num;	for(int i = 0;i < Thread_Num; i++)	{		Clienter *client = new Clienter[Worker_Num];		assert(client);		struct event_base *w_base = event_base_new();		assert(w_base);		for(int j = 0;j < Worker_Num; j++)		{			std::stringstream si,sj;			si<<i;			sj<<j;			Clienter *temp = &client[j];			temp->base = w_base;			temp->index = si.str()+"_"+sj.str();			temp->bufev = bufferevent_socket_new(w_base,-1,BEV_OPT_CLOSE_ON_FREE);			bufferevent_setcb(temp->bufev,worker_read_cb,NULL,worker_error_cb,temp);			bufferevent_enable(temp->bufev, EV_READ|EV_WRITE);			event_assign(&temp->timer,w_base,-1,0,connect_server_cb,temp);			update_timer(&temp->timer,2);			si.clear();			sj.clear();		}		pthread_t thread;        pthread_create(&thread,NULL,start_base_to_work,w_base);	}	return true;}bool Server::Server_Stop(){	std::cout<<"This is func: "<<__func__<<" line: "<<__LINE__<<std::endl;	return true;}