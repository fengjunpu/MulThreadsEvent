 #include <sys/socket.h>#include <netinet/in.h>#include <arpa/inet.h>#include <sys/types.h> #include <cstring>#include <sstream>#include <pthread.h>#include <sys/types.h> #include <sys/socket.h>#include <arpa/inet.h>#include <cstdio>#include <cstdlib>#include <errno.h>#include "../include/server.h"#define MAX_LINE 2048Server* Server::serobj = NULL;std::string getString(Json::Value &table){	std::string temp;    Json::StyledWriter writer(temp);    writer.write(table);    return temp;}int update_timer(struct event *timer,int tim){	struct timeval tv;	evutil_timerclear(&tv);	tv.tv_sec = tim;	tv.tv_usec = 0;	event_add(timer,&tv);	return 0;}void worker_read_cb(struct bufferevent *bev, void *ctx){	if(NULL == ctx)		return;	int n,len;	Clienter *clienter = (Clienter *)ctx;	char content[MAX_LINE + 1] = {0,};	while (n = bufferevent_read(bev, content, MAX_LINE),n > 0)	{		content[n] = '\0';	}	char *StrRet = strstr(content,"MSG_AGENT_REGISTER_RSP");	if(StrRet != NULL)	{		if(event_initialized(&clienter->timer))			event_del(&clienter->timer);		event_assign(&clienter->timer,clienter->base,-1,EV_TIMEOUT,write_timer_cb,clienter);		update_timer(&clienter->timer,120);	}	else	{		std::cout<<"this is worker read cb count :"<<content<<std::endl;	}	return;}void worker_error_cb(struct bufferevent *bev, short what, void *ctx){	if(NULL == ctx)		return;	Clienter *clienter = (Clienter *)ctx;	clienter->sockfd = -1;	std::cout<<"@@@@@conn failed index :"<<clienter->index<<std::endl;	bufferevent_disable(bev,EV_READ|EV_WRITE);	if(event_initialized(&clienter->timer))		event_del(&clienter->timer);	evutil_socket_t fd = bufferevent_getfd(bev);	evutil_closesocket(fd);	if(event_initialized(&clienter->conner->timer))		event_del(&clienter->conner->timer);	event_assign(&clienter->conner->timer,clienter->conner->base,-1,0,connect_server_cb,clienter->conner);	update_timer(&clienter->conner->timer,10);}void *start_base_to_work(void *arg){	if(NULL == arg)		return NULL;	struct event_base *base = (struct event_base *)arg;	event_base_dispatch(base);	std::cout<<"999999999999999999999999 base = "<<base<<std::endl;}void write_timer_cb(evutil_socket_t fd, short event, void *arg){	if(NULL == arg)		return;		Clienter *clienter = (Clienter *)arg;	int optval = -1;    int optlen = sizeof(optval);    int ret = getsockopt(clienter->sockfd, SOL_SOCKET, SO_ERROR, &optval, (socklen_t *)&optlen);    if(ret < 0 || optval != 0)	{		evutil_closesocket(clienter->sockfd);		clienter->sockfd = -1;		std::cout<<"get socket opt failed index = "<<clienter->index<<" optval: "<<optval<<" fd = "<<fd<<std::endl;		if(event_initialized(&clienter->conner->timer))			event_del(&clienter->conner->timer);		event_assign(&clienter->conner->timer,clienter->conner->base,-1,0,connect_server_cb,clienter->conner);		update_timer(&clienter->conner->timer,10);		return;	}	else	{		bufferevent_setfd(clienter->bufev,clienter->sockfd);		bufferevent_enable(clienter->bufev, EV_READ|EV_WRITE);	}		Json::Value reqConn = Json::Value::null;	reqConn["AgentProtocol"]["Header"]["Version"] = "1.0";	reqConn["AgentProtocol"]["Header"]["CSeq"] = "1";		reqConn["AgentProtocol"]["Header"]["MessageType"] = "MSG_AGENT_REGISTER_REQ";		reqConn["AgentProtocol"]["Body"]["Area"] = "Asia:China:Guangzhou";	reqConn["AgentProtocol"]["Body"]["AuthCode"] = clienter->index;		reqConn["AgentProtocol"]["Body"]["RewriteOemID"] = "General";	reqConn["AgentProtocol"]["Body"]["DevicePort"] = "34567";	reqConn["AgentProtocol"]["Body"]["SerialNumber"] = clienter->index;	std::string strreqCon = getString(reqConn);	int reqbodylen = strreqCon.length();		std::stringstream sl;	sl<<reqbodylen;	std::string strreqconnlen = sl.str();	std::string reqConnHead = "POST / HTTP/1.1\r\n";	std::string reqConnCseq = "CSeq: 3\r\n";	std::string reqConnLen = "Content-Length: ";	std::string reqConnend = "\r\n\r\n";	std::string reqConnHeader = reqConnHead + reqConnCseq + reqConnLen + strreqconnlen + reqConnend;	std::string reqConndata = reqConnHeader + strreqCon;	int reqConndatalen = reqConndata.length();	bufferevent_write(clienter->bufev,reqConndata.c_str(),reqConndatalen);		sl.clear();	return;}void connect_server_cb(evutil_socket_t fd, short event, void *arg){	/*Á¬½Óserver*/	if(NULL == arg)		return;	Connecter *conner = (Connecter *)arg;	int sockfd = socket(AF_INET,SOCK_STREAM,0);	evutil_make_socket_nonblocking(sockfd);	struct sockaddr_in addr;	addr.sin_family = AF_INET;	addr.sin_port = htons(6610);	addr.sin_addr.s_addr = inet_addr("203.12.202.231");	socklen_t addrlen = sizeof(struct sockaddr_in);	int Ret = connect(sockfd, (const struct sockaddr *)&addr,addrlen);	if(Ret == 0 || (Ret < 0 && errno == EINPROGRESS))	{		if(event_initialized(&conner->timer))			event_del(&conner->timer);		if(event_initialized(&conner->clienter->timer))			event_del(&conner->clienter->timer);		conner->clienter->sockfd = sockfd;		event_assign(&conner->clienter->timer,conner->clienter->base,-1,EV_TIMEOUT,write_timer_cb,conner->clienter);		update_timer(&conner->clienter->timer,5);	}	else if(Ret < 0 && errno != EINPROGRESS)	{		perror("conn server failed: ");		evutil_closesocket(sockfd);		if(event_initialized(&conner->timer))			event_del(&conner->timer);		event_assign(&conner->timer,conner->base,-1,0,connect_server_cb,conner);		update_timer(&conner->timer,10);	}}Server* Server::getInstance(){	if(NULL == serobj)	{		serobj = new Server;
	}
	return serobj;}void conn_timer_cb(evutil_socket_t fd, short event, void *arg){	std::cout<<"hello world\n";	return;}bool Server::Server_Start(int thread_num,int worker_num,int start_post){	if(evthread_use_pthreads() != 0) return false;	Thread_Num = thread_num;	Worker_Num = worker_num;	for(int i = 0;i < Thread_Num; i++)	{		Clienter *client = new Clienter[Worker_Num];		Connecter *conner = new Connecter[Worker_Num+1];		assert(client&&conner);		struct event_base *w_base = event_base_new();		struct event_base *n_base = event_base_new();		assert(w_base&&n_base);		for(int j = 0;j < Worker_Num; j++)		{			std::stringstream si,sj;			si<<(start_post+i);			sj<<j;			Connecter *conn_temp = &conner[j];			Clienter *client_temp = &client[j];			/*connecter*/			conn_temp->base = n_base;			conn_temp->clienter = client_temp;			event_assign(&conn_temp->timer,n_base,-1,0,connect_server_cb,conn_temp);			int time = j%10 + 1;			std::cout<<"timer = "<<time<<std::endl;			update_timer(&conn_temp->timer,time);			/*clienter*/			client_temp->sockfd = -1;			client_temp->conner = conn_temp;			client_temp->base = w_base;			client_temp->index = si.str()+"_"+sj.str();			client_temp->bufev = bufferevent_socket_new(w_base,-1,BEV_OPT_CLOSE_ON_FREE);			bufferevent_setcb(client_temp->bufev,worker_read_cb,NULL,worker_error_cb,client_temp);			bufferevent_enable(client_temp->bufev, EV_READ|EV_WRITE);						si.clear();			sj.clear();		}		struct event *ev = event_new(n_base,-1,EV_TIMEOUT|EV_PERSIST,conn_timer_cb,NULL);		update_timer(ev,60);		pthread_t thread[2];       	pthread_create(&thread[1],NULL,start_base_to_work,w_base);		pthread_create(&thread[2],NULL,start_base_to_work,n_base);	}	return true;}bool Server::Server_Stop(){	std::cout<<"This is func: "<<__func__<<" line: "<<__LINE__<<std::endl;	return true;}
