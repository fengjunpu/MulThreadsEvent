#include <sys/socket.h>#include <netinet/in.h>#include <arpa/inet.h>#include <sys/types.h> #include <cstring>#include <pthread.h>#include "../include/server.h"#include "../include/common_cb.h"Server* Server::serobj = NULL;
Server* Server::getInstance(){	if(NULL == serobj)	{		serobj = new Server;
	}
	return serobj;}int Server::Get_Node_Count(){	int count = 0;	pthread_mutex_lock(&s_lock_node_map);	count = dev_node_container.size();	pthread_mutex_unlock(&s_lock_node_map);	return count;}std::string Server::Get_Redis_Center_IP(){	return redis_center_ip;}void Server::Accept_Conn(struct evconnlistener *ptr, evutil_socket_t fd, struct sockaddr *addr, int socklen, void *arg){	if(fd <= 0)		return ;	Server *s_data = Server::getInstance();	int m_index = (s_data->index++)%(s_data->m_threadnum);	if(s_data->index == s_data->m_threadnum)		s_data->index = 0;	evutil_make_socket_nonblocking(fd);	struct bufferevent *bufev = bufferevent_socket_new(s_data->worker_base[m_index].w_base,fd,BEV_OPT_CLOSE_ON_FREE);	if(NULL == bufev) 		return ;	Conn *con_obj = (Conn *)calloc(sizeof(Conn),1);	assert(con_obj);	con_obj->bufev = bufev;	con_obj->pPeer = NULL;	con_obj->timer = event_new(s_data->worker_base[m_index].w_base,-1,EV_TIMEOUT,peer_timeout_cb,con_obj);	con_obj->base = s_data->worker_base[m_index].w_base;	con_obj->hredis = &s_data->handle_redis[m_index];	bufferevent_setcb(bufev,worker_read_cb, NULL,worker_error_cb,con_obj);	bufferevent_enable(bufev,EV_READ|EV_WRITE);	update_timer_event(con_obj->timer,HEART_BEAT_TIMEOUT);	return;}bool Server::Server_Start(int thread_num){	//if(evthread_use_pthreads() != 0) return false;	/*初始化Server 相关的信息*/	index = 0;	m_threadnum = thread_num;	pthread_mutex_init(&s_lock_node_map,NULL);	dev_node_container.clear();		/*设置监听回调*/	base = event_base_new();	assert(base);	struct sockaddr_in addr;	memset(&addr,0,sizeof(addr));	addr.sin_family = AF_INET;	addr.sin_port = htons(RPS_SERVER_PORT);	addr.sin_addr.s_addr = inet_addr("0.0.0.0");	evconnlistener_new_bind(base,Accept_Conn,NULL,LEV_OPT_REUSEABLE|LEV_OPT_CLOSE_ON_FREE,8192,(struct sockaddr*)&addr,sizeof(addr));	/*初始化Worker 实例*/	worker_base = new WorKBase[thread_num];	assert(worker_base);	handle_redis = new SyRedis[thread_num];	assert(handle_redis);	for(int i = 0;i < thread_num;i++)	{		pthread_t thread;		//设置用于业务处理的base实例		worker_base[i].w_base = base;		assert(worker_base[i].w_base);		worker_base[i].index = i;				//设置redis相关的事件		handle_redis[i].index = i;		handle_redis[i].redis_conn_flag = 0;		handle_redis[i].r_status  = redisAsyncConnect(REDIS_CENTER_IP,REDIS_STATUS_PORT);		handle_redis[i].w_base = worker_base[i].w_base;		handle_redis[i].r_status->data = &handle_redis[i];			redisLibeventAttach(handle_redis[i].r_status,worker_base[i].w_base);		redisAsyncSetConnectCallback(handle_redis[i].r_status,redis_conn_cb);		redisAsyncSetDisconnectCallback(handle_redis[i].r_status,redis_disconn_cb);	}	event_base_dispatch(base);	return false;}bool Server::Server_Stop(){		std::cout<<"This is func: "<<__func__<<" line: "<<__LINE__<<std::endl;	return true;}