#include <sys/socket.h>#include <netinet/in.h>#include <arpa/inet.h>#include <sys/types.h> #include <cstring>#include <pthread.h>#include "../include/server.h"#include "../include/common_cb.h"int g_redis_change_flag_index = 0;Server* Server::serobj = NULL;
Server* Server::getInstance(){	if(NULL == serobj)	{		serobj = new Server;
	}
	return serobj;}int Server::Get_Node_Count(){	int count = 0;	pthread_mutex_lock(&s_lock_node_map);	count = dev_node_container.size();	pthread_mutex_unlock(&s_lock_node_map);	return count;}std::string Server::Get_Redis_Center_IP(){	return redis_center_ip;}void Server::Accept_Conn(struct evconnlistener *ptr, evutil_socket_t fd, struct sockaddr *addr, int socklen, void *arg){	if(fd <= 0)		return ;	Server *s_data = Server::getInstance();	evutil_make_socket_nonblocking(fd);	Conn *con_obj = (Conn *)calloc(1,sizeof(Conn));	assert(con_obj);	struct event *pTimer = event_new(s_data->base,-1,EV_TIMEOUT,peer_timeout_cb,con_obj);	if(NULL == pTimer)	{		free(con_obj);		return ;	}		struct bufferevent *bufev = bufferevent_socket_new(s_data->base,fd,BEV_OPT_CLOSE_ON_FREE);	if(NULL == bufev) 	{		event_free(pTimer);		free(con_obj);		return ;	}	con_obj->bufev = bufev;	con_obj->pPeer = NULL;	con_obj->timer = pTimer;	con_obj->base = s_data->base;	con_obj->hredis = s_data->handle_redis;		update_timer_event(con_obj->timer,HEART_BEAT_TIMEOUT);	bufferevent_setcb(con_obj->bufev,worker_read_cb, NULL,worker_error_cb,con_obj);	bufferevent_enable(con_obj->bufev,EV_READ);	return;}bool Server::Server_Start(){	/*初始化Server 相关的信息*/	pthread_mutex_init(&s_lock_node_map,NULL);	dev_node_container.clear();			/*设置监听回调*/	base = event_base_new();	assert(base);	struct sockaddr_in addr;	memset(&addr,0,sizeof(addr));	addr.sin_family = AF_INET;	addr.sin_port = htons(RPS_SERVER_PORT);	addr.sin_addr.s_addr = inet_addr("0.0.0.0");	evconnlistener_new_bind(base,Accept_Conn,NULL,LEV_OPT_REUSEABLE|LEV_OPT_CLOSE_ON_FREE,8192,(struct sockaddr*)&addr,sizeof(addr));		//设置redis相关的事件	handle_redis = new SyRedis;	assert(handle_redis);		handle_redis->redis_conn_flag = 0;	handle_redis->r_status  = redisAsyncConnect(REDIS_STATUS_IP,REDIS_STATUS_PORT);	handle_redis->w_base = base;	handle_redis->r_status->data = handle_redis;		redisLibeventAttach(handle_redis->r_status,base);	redisAsyncSetConnectCallback(handle_redis->r_status,redis_conn_cb);	redisAsyncSetDisconnectCallback(handle_redis->r_status,redis_disconn_cb);	//驱动base开始工作	log_debugx("Begin to work");	event_base_dispatch(base);	return false;}bool Server::Server_Stop(){	redisAsyncFree(handle_redis->r_status);	delete handle_redis;	//std::cout<<"This is func: "<<__func__<<" line: "<<__LINE__<<std::endl;	return true;}
